#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2010.

# SMHI,
# Folkborgsvägen 1,
# Norrköping, 
# Sweden

# Author(s):
 
#   Martin Raspaud <martin.raspaud@smhi.se>

# This file is part of mpop.

# mpop is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.

# mpop is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with
# mpop.  If not, see <http://www.gnu.org/licenses/>.
"""Interface to Eumetcast level 1.5 format. Uses the MIPP reader.
"""


from ConfigParser import ConfigParser
from satin import CONFIG_PATH
import xrit.sat
from satin.logger import LOG
import os
import numpy as np
import datetime

def load(satscene):
    """Read data from file and load it into *satscene*.
    """    
    conf = ConfigParser()
    conf.read(os.path.join(CONFIG_PATH, satscene.fullname + ".cfg"))
    options = {}
    for option, value in conf.items(satscene.instrument_name + "-level2"):
        options[option] = value
    CASES.get(satscene.instrument_name, load_generic)(satscene, options)

def load_mviri(satscene, options):
    """Read mviri data from file and load it into *instrument_instance*.
    """
    os.environ["PPP_CONFIG_DIR"] = CONFIG_PATH

    LOG.debug("Channels to load from mviri: %s"%satscene.channels_to_load)
    satscene.info = {}
    # Compulsory global attribudes
    satscene.info["Conventions"] = "CF-1.4"
    satscene.info["title"] = ("Meteosat 7 geostationary satellite, "
                              "Mviri instrument.")
    satscene.info["institution"] = "Original data disseminated by EumetCast."
    satscene.info["history"] = (str(datetime.datetime.now()) +
                                " - original data read by mipp, "
                                "netCDF generated by mpop.")
    satscene.info["references"] = "No reference."
    satscene.info["comments"] = "No comment."

    # Other global attributes
    satscene.info["platform_name"] = satscene.satname
    satscene.info["platform_number"] = satscene.number
    satscene.info["service"] = satscene.variant
    satscene.info["time"] = satscene.time_slot
    satscene.info["area_name"] = satscene.area_id

    for chn in satscene.channels_to_load:
        metadata, data = xrit.sat.load_meteosat07(satscene.time_slot,
                                                  chn,
                                                  mask = True)()
        satscene[chn] = data

        satscene[chn].info = {
            'var_name' : chn,
            'var_data' : satscene[chn].data,
            'var_dim_names': ('x'+str(satscene[chn].resolution),
                              'y'+str(satscene[chn].resolution)),
            'valid_range' : np.array([satscene[chn].data.min(),
                                      satscene[chn].data.max()]),
            'standard_name' : chn,
            'area_name': satscene[chn].area_id or "",
            'scale_factor' : 1.0, 
            'add_offset' : 0.0,
            'units': metadata.calibration_unit            
            }
        
        if chn == "00_7":
            satscene[chn].area_id = "HR" + satscene.area_id
        else:
            satscene[chn].area_id = satscene.area_id

    if(len(satscene.channels_to_load) > 1 and
       "00_7" in satscene.channels_to_load):
        satscene.area_id = None

def load_seviri(satscene, options):
    """Read seviri data from file and load it into *instrument_instance*.
    """
    os.environ["PPP_CONFIG_DIR"] = CONFIG_PATH

    LOG.debug("Channels to load from seviri: %s"%satscene.channels_to_load)
    
    satscene.info = {}

    # Compulsory global attribudes
    satscene.info["Conventions"] = "CF-1.4"
    satscene.info["title"] = ("Meteosat 9 geostationary satellite, "
                              "Seviri instrument.")
    satscene.info["institution"] = "Original data disseminated by EumetCast."
    satscene.info["history"] = (str(datetime.datetime.now().isoformat()) +
                                " - original data read by mipp, "
                                "netCDF generated by mpop.")
    satscene.info["references"] = "No references."
    satscene.info["comments"] = "No comment."

    # Other global attributes
    satscene.info["platform_name"] = satscene.satname
    satscene.info["platform_number"] = satscene.number
    satscene.info["service"] = satscene.variant
    satscene.info["time"] = satscene.time_slot
    satscene.info["area_name"] = satscene.area_id

    from pyresample import utils

    area_file = os.path.join(CONFIG_PATH, "areas.def")
    area_def = utils.parse_area_file(area_file, satscene.area_id)[0]

    if(area_def.proj_dict["proj"] != "geos" or
       area_def.proj_dict["lon_0"] != "0.0"):
        raise ValueError("Slicing area must be in geos0 projection.")

    ll_x, ll_y, ur_x, ur_y = area_def.area_extent
    ll_x = int(np.round(-(ll_x / 3000.4) + 3712 / 2))
    ll_y = int(np.round((ll_y / 3000.4) + 3712 / 2))
    ur_x = int(np.round(-(ur_x / 3000.4) + 3712 / 2))
    ur_y = int(np.round((ur_y / 3000.4) + 3712 / 2))
    
    for chn in satscene.channels_to_load:
        if chn == "HRV":
            (l_x, l_y, u_x, u_y) = (ll_x * 3, ll_y * 3, ur_x * 3, ur_y * 3)
        else:
            l_x, l_y, u_x, u_y = int(ll_x), int(ll_y), int(ur_x), int(ur_y)
            
        metadata, data = xrit.sat.load_meteosat09(satscene.time_slot,
                                                  chn,
                                                  mask=True,
                                                  calibrate=True)[l_y:u_y,
                                                                   u_x:l_x]
        satscene[chn] = data

        satscene[chn].info = {
            'var_name' : chn,
            'var_data' : satscene[chn].data,
            'var_dim_names': ('x'+str(satscene[chn].resolution),
                              'y'+str(satscene[chn].resolution)),
            'valid_range' : np.array([satscene[chn].data.min(),
                                      satscene[chn].data.max()]),
            'bandname' : chn,
            'area_name': satscene[chn].area_id or "",
            'scale' : 1.0, 
            'offset' : 0.0,
            'units': metadata.calibration_unit
            }

        if chn == "HRV":
            satscene[chn].area_id = "HR" + satscene.area_id
        else:
            satscene[chn].area_id = satscene.area_id

    for key in metadata.__dict__:
        if (not isinstance(metadata.__dict__[key],
                           (int, long, float, complex, str, np.ndarray)) or
            isinstance(metadata.__dict__[key], bool)):
            satscene.info[key] = str(metadata.__dict__[key])
        else:
            satscene.info[key] = metadata.__dict__[key]

            
        
    if(len(satscene.channels_to_load) > 1 and
       "HRV" in satscene.channels_to_load):
        satscene.area_id = None

def load_generic(satscene, options):
    """Read instrument data from file and load it into *instrument_instance*.
    """
    os.environ["PPP_CONFIG_DIR"] = CONFIG_PATH

    LOG.debug("Channels to load from %s: %s"%(satscene.instrument_name,
                                              satscene.channels_to_load))
    
    satscene.info = {}

    # Compulsory global attribudes
    satscene.info["Conventions"] = "CF-1.4"
    satscene.info["title"] = ("Meteosat 9 geostationary satellite, "
                              "Seviri instrument.")
    satscene.info["institution"] = "Original data disseminated by EumetCast."
    satscene.info["history"] = (str(datetime.datetime.now().isoformat()) +
                                " - original data read by mipp, "
                                "netCDF generated by mpop.")
    satscene.info["references"] = "No reference."
    satscene.info["comments"] = "No comment."

    # Other global attributes
    satscene.info["platform_name"] = satscene.satname
    satscene.info["platform_number"] = satscene.number
    satscene.info["service"] = satscene.variant
    satscene.info["time"] = satscene.time_slot
    satscene.info["area_name"] = ""

    for chn in satscene.channels_to_load:

        metadata, data = xrit.sat.load(satscene.fullname,
                                       satscene.time_slot,
                                       chn,
                                       mask=True,
                                       calibrate=True)()
        satscene[chn] = data

        from pyresample.geometry import AreaDefinition

        area_id = satscene.fullname + str(satscene[chn].resolution)
        name = ("Full disc for " +
                satscene.fullname +
                " at resolution "+
                str(satscene[chn].resolution) + ".")
        proj_id = "geos"+str(metadata.sublon)
        x_size = metadata.image_size[0]
        y_size = metadata.image_size[1]
        area_extent = (-x_size * satscene[chn].resolution / 2,
                       -y_size * satscene[chn].resolution / 2,
                       x_size * satscene[chn].resolution / 2,
                       y_size * satscene[chn].resolution / 2)
        proj_dict = {'ellps': 'WGS84', 'units': 'm',
                     'lon_0': str(metadata.sublon),
                     'proj': 'geos', 'h': str(35785831.0)}
        area = AreaDefinition(area_id, name, proj_id, proj_dict,
                              x_size, y_size, area_extent)

        satscene[chn].info = {
            'var_name' : chn,
            'var_data' : satscene[chn].data,
            'var_dim_names': ('x'+str(satscene[chn].resolution),
                              'y'+str(satscene[chn].resolution)),
            'valid_range' : np.array([satscene[chn].data.min(),
                                      satscene[chn].data.max()]),
            'bandname' : chn,
            'area_name': satscene[chn].area_id or "",
            'scale' : 1.0, 
            'offset' : 0.0,
            'units': metadata.calibration_unit
            }
        satscene[chn].area_id = area

    for key in metadata.__dict__:
        if (not isinstance(metadata.__dict__[key],
                           (int, long, float, complex, str, np.ndarray)) or
            isinstance(metadata.__dict__[key], bool)):
            satscene.info[key] = str(metadata.__dict__[key])
        else:
            satscene.info[key] = metadata.__dict__[key]

            
        
CASES = {
    "mviri": load_mviri,
    "seviri": load_seviri
    }
